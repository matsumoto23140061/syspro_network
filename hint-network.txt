## 乱数文字列

文字列は乱数で生成したものを用いると良い．
乱数で文字を生成するコードは，次のとおりである．

```
#include <random>  // コードの最初の方に記載する．

random_device rd;
mt19937_64 mt(rd());
uniform_int_distribution<char> cU(30, 80);
char c = cU(mt);  // これを繰り返して，string 型などに格納して，文字列にする．
```

## 長いデータの分割送信

`sendto` で送るデータ量は，最大 6 万 B など，制限がある．
これ以上のデータを送るには，分割してデータを送る．
受信側でも `recvfrom` を複数回呼び出す必要がある．
パケットの長さは最大 1400 B 程度であるため，これを超える長さのデータを送る場合は，分割して送信することを考える．
サンプルコード中の `BUFF_SIZE` を変更するだけでは，うまく動作しないことに注意する．
`BUFF_SIZE` は最大でも 1000 程度にする．

送信は簡単のために今，

```
sendto(socketd, msg.c_str(), msg.size(), ...
```

のように `msg` の内容を一度に指定しているが，これを受信と同様に，

```
sendto(socketd, buff, BUFF_SIZE , ...
```

と変更して，繰り返し分で複数回 `sendto` を呼び出すように変更する．
`buff` の内容は， `msg` の内容を順番に書き込む．

```
buff[c] = msg[i]; i++; c++;
```

などとして， `i` が `msg` の長さに達するか， `c` が `BUFF_SIZE` に達した場合に， `sendto` を呼び出せばいい（ `c` は `sendto` 呼び出しごとに `0` とする．）．
`i` が `msg` の長さに達したら，送信の繰り返しを終了する．

受信について，送信されるパケットの数が受信側ではわからないため，データの終わりを別途受信側に伝える仕組みを必要がある．
簡単な方法として，データの末尾に特殊な文字（ `char(1)` など，終端文字列と呼ぶ）を付加して送信する方法が考えられる．
受信側は，受信を一度始めたら，終端文字列が現れるまで読み続け，終端文字列が現れたら，すべて受信を完了したとして，次の処理に進むようにする．
繰り返し文により `recvfrom` を繰り返し呼び出す方法は，送信のときの方法とほぼ同様である．
TCP においても，一度に write により送ることができるデータの量には，制限があるため，長い文字列を送る場合，上記同様分割して送る．

## プログラム強制終了について

プログラムを強制終了する場合，クライアント側から終了すると，サーバ側に問題が生じにくい．
クライアントが接続を行っている状態でサーバ側から強制終了すると，そのサーバが使っていたポートにまだパケットが到達する可能性があるため，OS がしばらくの間そのポートを使えないようにする．

どうしてもポートが使えない場合は，`$X` をプログラムの名前として，以下のコマンド

```
ps -aux | grep $X
```

でプロセス番号（表示される 2 列目の数値）を調べて，プロセス番号を `$i` として，

```
kill -9 $i
```

により，プロセスを強制終了する．
これでも解決しない場合は，3 分待つか，別のポートを使うか，OS を再起動する．
再起動すれば確実に直る．

## 実験の統計について

実験は，一つの文字長さに対し，複数回行い結果を平均すると，たまたまの結果と，平均的な結果を見極めることができるようになるため，結果が考察しやすい．
